DO.DEFINES:
  DEF FN PEEKW(A)=PEEK(A)+(PEEK(A+1)*256)
## CONVERT TO SIGNED RANGE
  DEF FN SW(W)=W + 65536 * (W > 32767)
## CONVERT TO UNSIGNED RANGE
  DEF FN UW(W)=W-65536*(W<0)
  DEF FN Lo.Byte(X)=(FN SW(X)) AND $FF
  DEF FN Hi.Byte(X)=INT(FN UW(X)/256)
  DEF FN SIGNED.BYTE(N) = N+256*(N>127)
  DEF FN ROUND(X) = INT(X+.5)
RETURN

FLUSHKEYS:
  FOR I = 0 TO -1 STEP 0:GET X$:I=(X$=""):NEXT:RETURN


CLEAR.GRAPHICSBUFFER:
  POKE VERA.LOWADDR, 0
  POKE VERA.MIDADDR, 0
  POKE VERA.HIGHADDR, %00010000
  FOR I= 1 TO 2
    POKE R0L, $23
    POKE R0H, $9F
    POKE R1L, $00
    POKE R1H, $96
    POKE A.REG, 0
    SYS MEM.FILL
  NEXT
RETURN

FILL.TEXTSCREEN:
 IF NO.TEXTURE THEN COLOR 0:PRINT CHR$(1):CLS:PRINT CHR$(1):RETURN
 POKE VERA.LOWADDR, 0
 POKE VERA.MIDADDR, $B0
 POKE VERA.HIGHADDR, %00100001
 POKE A.REG, CH%
 POKE R0L, $23
 POKE R0H, $9F
 POKE R1L, 0
 POKE R1H, $1E
 SYS MEM.FILL
 POKE VERA.LOWADDR, 1
 POKE VERA.MIDADDR, $B0
 POKE VERA.HIGHADDR, %00100001
 POKE A.REG, PEEK(COLOR.BYTE)
 POKE R0L, $23
 POKE R0H, $9F
 POKE R1L, 0
 POKE R1H, $1E
 SYS MEM.FILL
RETURN

SETDEFAULTPALETTE:
  F$=PF$:GOSUB FILEEXISTS
  IF FE% THEN BVLOAD F$,DEVICE,1,$FA00:RETURN
  ERR$="MISSING DPAL.BIN !!":RETURN

CLSALL:
 CLS
CLSGRAPH:
 RECT ZERO,ZERO,XLIMIT,YLIMIT,.:RETURN

HIDEALL:
  GOSUB HIDEGRAPHICS:GOTO HIDETEXT
SHOWALL:
  GOSUB SHOWGRAPHICS:GOTO SHOWTEXT

HIDEGRAPHICS:
  POKE VERA.DCVIDEO, PEEK(VERA.DCVIDEO) AND LAYER0.OFF:RETURN

SHOWGRAPHICS:
  POKE VERA.DCVIDEO, PEEK(VERA.DCVIDEO) OR LAYER0.ON:RETURN

HIDETEXT:
  POKE VERA.DCVIDEO, PEEK(VERA.DCVIDEO) AND LAYER1.OFF:RETURN

SHOWTEXT:
  POKE VERA.DCVIDEO, PEEK(VERA.DCVIDEO) OR LAYER1.ON:RETURN

TEXTBOX:
  LOCATE Y,X:PRINT CHR$(DChars%(1));RPT$(DChars%(2),W-2);CHR$(DChars%(3));
  IF H=2 THEN SKIPMID
  BStart=Y+1:BEnd=Y+(H-2)
  FOR Y2 = BStart TO BEnd:LOCATE Y2,X:PRINT CHR$(DChars%(4));RPT$(32,W-2);CHR$(DChars%(5));:NEXT
SKIPMID:
  LOCATE Y+H-1,X:PRINT CHR$(DChars%(6));RPT$(DChars%(7),W-2);CHR$(DChars%(8));:RETURN

LoadDCharsCP437:
 RESTORE CP437DRAW
 GOTO Load.Them.Chars

LoadDChars:
 RESTORE PETSCIIDRAW
Load.Them.Chars:
  FOR I=1 TO 8:READ DChars%(I):Next
  RETURN

PETSCIIDRAW:
 DATA $CF,$B7,$D0,$B4,$AA,$CC,$EF,$BA

CP437DRAW:
 DATA $C9,$CD,$BB,$BA,$BA,$C8,$CD,$BC

POSITION:
  COMMAND$="P"+CHR$(CHANNEL)+CHR$(P0)+CHR$(P1)+CHR$(P2)+CHR$(P3)
  GOTO DOS.CMD

KILLFILE:
 GOSUB FILEEXISTS:IF NOT FE% THEN RETURN
 COMMAND$="S:"+F$:GOTO DOS.CMD


FILEEXISTS:
  OPEN 2,DEVICE,2,F$+",S,R":CLOSE 2
  GOSUB GETFILECODE
  FE%=(FCode<20)
  RETURN

DOS.CMD:
 OPEN 15,DEVICE,15, COMMAND$
 GOTO GETFCODE

GETFILECODE:
  OPEN 15,DEVICE,15
GETFCODE:
  INPUT#15,FCode,FC$,FCode2,FCode3:CLOSE 15:RETURN

PLOTXY:
  POKE C.REG, 1:SYS PLOT:X=PEEK(Y.REG)+1:Y=PEEK(X.REG)+1:RETURN

SaveCursor.AndColor:
  SavedColor = PEEK(COLOR.BYTE):POKE C.REG, 1:SYS PLOT
  SavedX = PEEK(X.REG):SavedY = PEEK(Y.REG)
  RETURN

RestoreCursor.AndColor:
   POKE COLOR.BYTE, SavedColor
   POKE X.REG, SavedX:POKE Y.REG, SavedY:POKE C.REG, 0:SYS PLOT
   RETURN

FIXCURSOR:
  FBASE=$9F*8+$F000
  FOR X=0 TO 6:VPOKE 1,FBASE+X,0:NEXT X
  VPOKE 1,FBASE+7,$FF
  RETURN

## GetParamString:
## OldBank=PEEK(0)
## BANK 0
## ADDR=$BF00
## PARAM.STRING$=""
## FOR I = 0 TO 1 STEP 0
##     C=PEEK(ADDR)
##     IF C>0 THEN ADDR=ADDR+1
##     PARAM.STRING$=PARAM.STRING$+CHR$(C)
##     IF C=0 THEN I=1
## NEXT
## BANK OldBank:RETURN

## PUTPARAMMSG:
##   PARAM.STRING$=ZSM.MSG$

## PutParamString:
##  OldBank=PEEK(0)
##  BANK 0
##  ADDR=$BF00
##  IF LEN(PARAM.STRING$)=0 THEN SKIPPUT
##  FOR I=1 TO LEN(PARAM.STRING$)
##    POKE ADDR, ASC(MID$(PARAM.STRING$,I))
##    ADDR=ADDR+1
##  NEXT
##  POKE ADDR, 0
##  RETURN

ClearParamBuffer:
   OB=PEEK(0):BANK 0
   FOR ADDR = $BF00 TO $BFFF:POKE ADDR, 0:NEXT
   BANK OB:RETURN

SAVE.SCREEN.MODE:
   POKE C.REG, 1
   SYS SCREEN.MODE
   SAVEDMODE = PEEK(A.REG)
   RETURN

RESTORE.SCREEN.MODE:
   SCREEN SAVEDMODE
   RETURN

Setup.Banked.Ram:
  POKE C.REG,1
  SYS MEM.TOP
  NUM.BANKS = PEEK(A.REG)
  IF NUM.BANKS=0 THEN NUM.BANKS=256
  HI.Bank=NUM.BANKS-1
  LO.Bank = 2
  Scratch.BANK = HI.Bank
  HI.Bank = HI.Bank - 1
  FREE.Banks = (HI.Bank-LO.Bank) + 1
  RETURN


STRINGGET:
     GET X$:IF X$<>"" THEN STRINGGET
     IS$="":ID=0
     GOSUB AREACLR:IF IS$="" THEN PRINT CHR$(95);
     IF IS$<> "" THEN PRINT IS$;CHR$(95);
GETAKEY3:
     GET X$:IF X$="" THEN GETAKEY3
     C=ASC(X$):AC=0
     IF (IT<>2 OR IT=3) AND C>=65 AND C<=123 THEN AC=1
     IF (IT=2 OR IT=4 OR IT=3) AND C>=48 AND C<=57 THEN AC=1
     IF ((IT=2) AND C=46 AND ID=0) OR IT=3 THEN AC=1:ID=1
     IF (IT=4) AND C=32 THEN AC=1: REM ALLOW SPACES WHEN INPUTTING A LINE
     IF (IT=4) AND (C>=35 AND C<=47) THEN AC=1
     IF (IT=4) AND (C>=58 AND C<=63) THEN AC=1  : REM ALLOW PUNCS IN STRING.
     IF C=13 THEN S$=IS$:GOSUB RTRIM:IS$=S$:RETURN
     IF ((AC=1 AND LEN(IS$)<ML) AND C<>20 AND C<>27) THEN IS$=IS$+CHR$(C):FMDRUM 7,26:LOCATE IY,IX:PRINT IS$;CHR$(95);:GOTO GETAKEY3
     IF C<>20 AND C<>27 THEN TOLONG
     AC=0
     IF (IS$="" OR IS$=CHR$(27)) AND C=27 THEN IS$=CHR$(27):RETURN
     IF LEN(IS$)=0 THEN FMDRUM 7,87
     IF LEN(IS$)=1 OR LEN(IS$)=0 THEN IS$="":GOSUB AREACLR:GOTO GETAKEYEND
     I=LEN(IS$)-1
     IF RIGHT$(IS$,1)="." AND IT=2 THEN ID=0
     S$=IS$:I=LEN(S$)-1:IS$=MID$(S$,1,I)
GETAKEYEND:
     GOSUB AREACLR:PRINT IS$;CHR$(95);:FMDRUM 7,26:GOTO GETAKEY3
TOLONG:
     FMDRUM 7,87:GOTO GETAKEY3

AREACLR:
     LOCATE IY,IX:PRINT RPT$(32,ML+1);:LOCATE IY,IX:RETURN

ERRORHALT:
  IF MSG$="" THEN MSG$=ERRMSG$
  COLOR 1,0:PRINT:COLOR 10,0:PRINT "FATAL ERROR: ";
  COLOR 13,0:PRINT MSG$;"{CR}{CR}":COLOR 1,0:END

UCASE:
  IF S$="" THEN RETURN
  X$="":FOR I=1 TO LEN(S$):I$=MID$(S$,I,1):X=ASC(I$):IF X>=97 AND X<=122 THEN X=X-32
  X$=X$+CHR$(X):NEXT I:S$=X$:RETURN

TRIM:
  GOSUB LTRIM:GOTO RTRIM

LTRIM:
   IF S$="" THEN RETURN
   I=1:C1=0
DOLOOP:
   X$=MID$(S$,I,1):X=ASC(X$):IF X > 32 THEN LSTR
   C1=C1+1:I=I+1:IF I>LEN(S$) THEN LSTR
   GOTO DOLOOP
LSTR:
   IF C1=LEN(S$) THEN S$=""
   IF C1>0 AND C1<LEN(S$) THEN S$=MID$(S$,C1+1,LEN(S$)-C1)
   RETURN

RTRIM:
  IF S$="" THEN RETURN
  I=LEN(S$):C1=0
DOLOOPR:
  X$=MID$(S$,I,1):X=ASC(X$):IF X>32 THEN RSTR
  C1=C1+1:I=I-1:IF I<1 THEN RSTR
  GOTO DOLOOPR
RSTR:
  IF C1=LEN(S$) THEN S$=""
  IF C1>0 AND C1<LEN(S$) THEN S$=MID$(S$,1,LEN(S$)-C1)
  RETURN

INSTR:
    ISTR=ZERO
    IF T$="" OR S$="" OR (LEN(S$)>LEN(T$)) THEN RETURN
    S=LEN(S$):L=LEN(T$)-(S-1)
TESTLOOP:
    TST$=MID$(T$,L,S):IF TST$=S$ THEN ISTR=L
    IF ISTR<>L AND L>1 THEN L=L-1:GOTO TESTLOOP
    RETURN

GET.FileExtension:
  EXT$="":L=LEN(F$)
  IF L<2 THEN RETURN
  FOR C = 0 TO 1 STEP 0
      X$=MID$(F$,L,1):EXT$=X$+EXT$
      IF X$="." THEN C=1:GOTO EELOOP
      L=L-1:IF L=0 THEN C=1
EELOOP:
  NEXT C
  IF L=0 THEN EXT$=""
  RETURN

