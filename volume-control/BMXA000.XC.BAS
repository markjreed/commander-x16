OPTION NOBASICLOADER
OPTION STARTADDRESS = $A000
SHARED CONST TRUE = 255
SHARED CONST FALSE = 0
SHARED CONST R0 = 2
SHARED CONST R0L = 2
SHARED CONST R0H = 3
SHARED CONST R1 = 4
SHARED CONST R1L = 4
SHARED CONST R1H = 5
SHARED CONST R2 = 6
SHARED CONST R2L = 6
SHARED CONST R2H = 7
SHARED CONST R3 = 8
SHARED CONST R3L = 8
SHARED CONST R3H = 9
SHARED CONST R4 = $0A
SHARED CONST R4L = $0A
SHARED CONST R4H = $0B
SHARED CONST R5 = $0C
SHARED CONST R5L = $0C
SHARED CONST R5H = $0D
SHARED CONST R6 = $0E
SHARED CONST R6L = $0F
SHARED CONST R7 = $10
SHARED CONST R7L = $10
SHARED CONST R7H = $11
SHARED CONST R8 = $12
SHARED CONST R8L = $12
SHARED CONST R8H = $13
SHARED CONST R9 = $14
SHARED CONST R9L = $14
SHARED CONST R9H = $15
SHARED CONST R10 = $16
SHARED CONST R10L = $16
SHARED CONST R10H = $17
SHARED CONST R11 = $18
SHARED CONST R11L = $18
SHARED CONST R11H = $19
SHARED CONST R12 = $1A
SHARED CONST R12L = $1A
SHARED CONST R12H = $1B
SHARED CONST R13 = $1C
SHARED CONST R13L = $1C
SHARED CONST R13H = $1D
SHARED CONST R14 = $1E
SHARED CONST R14L = $1E
SHARED CONST R14H = $1F
SHARED CONST R15 = $20
SHARED CONST R15L = $20
SHARED CONST R15H = $20 
SHARED CONST screen_set_charset = $FF62
SHARED CONST MACPTR = $FF44
SHARED CONST MCIOUT = $FEB1
SHARED CONST CHKIN = $FFC6
SHARED CONST CHKOUT = $FFC9
SHARED CONST CLRCHN = $FFCC
SHARED CONST CHROUT = $FFD2
SHARED CONST CHRIN = $FFCF
SHARED CONST READST = $FFB7
SHARED CONST RDTIM = $FFDE
SHARED CONST SETTIM = $FFDB
SHARED CONST LOADER = $FFD5
SHARED CONST SETNAM = $FFBD
SHARED CONST SETLFS = $FFBA
SHARED CONST MEMTOP = $FF99
SHARED CONST MEM_COPY = $FEE7
SHARED CONST MEM_FILL = $FEE4
CONST Put_Kbd_Buf = $FEC3
SHARED CONST VERA_CTRL = $9F25
SHARED CONST VERA_DATA0 = $9F23
SHARED CONST VERA_ADDR_LOW = $9F20
SHARED CONST VERA_ADDR_MID = $9F21
SHARED CONST VERA_ADDR_HI = $9F22
SHARED CONST XLIMIT = 319
SHARED CONST YLIMIT = 239
SHARED CONST FB_cursor_position = $FEFF
SHARED CONST FB_cursor_nextline = $FF02
SHARED CONST LAYER0_ON=16
SHARED CONST LAYER0_OFF=239
SHARED CONST LAYER1_ON=32
SHARED CONST LAYER1_OFF=223
SHARED CONST AUTO_INCREMENT = %00010000


CONST XLIMIT=319
CONST YLIMIT=239
DIM BMX_HDR AS STRING * 33
DIM BMX_ID AS STRING * 3
DIM SHARED BMX_VERSION AS BYTE
DIM SHARED BMX_WIDTH AS WORD FAST
DIM SHARED BMX_HEIGHT AS WORD FAST
DIM SHARED BMX_PALUSED AS BYTE
DIM BMX_FIRSTPAL AS BYTE
DIM BMX_FILEOFFSET AS WORD
DIM BMX_COMPRESS AS BYTE
DIM SHARED BMX_VER AS BYTE
DIM SHARED BMX_BITS AS BYTE
DIM SHARED Is_Supported_BMX AS BYTE
DIM TMPBYTESL AS LONG FAST
DIM TMPBYTES AS WORD FAST
DIM BYTESTOGET AS WORD FAST
DIM BYTES_TO_READL AS LONG FAST
DIM BYTES_TO_READ AS WORD FAST
DIM X AS WORD
DIM Y AS WORD
DIM XR AS BYTE
DIM YR AS WORD
DIM VADDR AS WORD FAST
DIM A AS BYTE FAST
DIM FEEDBACK AS STRING * 80 @$BF00



SUB Flush_Kbd_Buffer() STATIC
 DIM _K AS BYTE
FLUSH:
 GET _K
 IF _K > 0 THEN GOTO FLUSH
END SUB


SUB CHAIN_PROG(PROGRAM AS STRING*96) STATIC
 END ASM
 END
END SUB

SUB READSMALLIMAGE() STATIC
 DIM A AS BYTE
    A=0
    XR = 0
    YR = 0
 X = ((XLIMIT+1)-BMX_WIDTH)/2
 IF BMX_HEIGHT>240 THEN BMX_HEIGHT=240
 IF BMX_HEIGHT=240 THEN Y=0
 IF BMX_HEIGHT <> 240 THEN Y = ((YLIMIT+1)-BMX_HEIGHT)/2

   ASM
     lda %00010000
     sta {VERA_ADDR_HI}
     lda {X}
     sta {R0L}
     lda {X}+1
     sta {R0H}
     lda #0
     sta {R1H}
     lda {Y}
     sta {R1L}
     jsr {FB_cursor_position}
    END ASM

  BYTESTOGET = BMX_WIDTH
  FOR I AS BYTE = 1 TO BMX_HEIGHT
     TMPBYTES=0
     DO
      BYTES_TO_READ=BYTESTOGET-TMPBYTES
      IF BYTES_TO_READ>255 THEN BYTES_TO_READ=255
      ASM
       lda {BYTES_TO_READ}
       ldx #$23
       ldy #$9F
       sec
       jsr {MACPTR}
       clc
       txa
       adc {TMPBYTES}
       sta {TMPBYTES}
       tya
       adc {TMPBYTES}+1
       sta {TMPBYTES}+1
      END ASM
    LOOP WHILE (TMPBYTES < BYTESTOGET)
    ASM
     jsr {FB_cursor_nextline}
    END ASM
  NEXT I
  ASM
   jsr {CLRCHN}
  END ASM
  CLOSE 4
END SUB


START_DECODE:
    BMX_WIDTH = DEEK(R0L)
    BMX_HEIGHT = DEEK(R1L)
    BMX_PALUSED = PEEK(R2L)
    BMX_FIRSTPAL = PEEK(R2H)

REM READ IN THE PALETTE

    TMPBYTES=0
    BYTESTOGET = CWORD(BMX_PALUSED)*2
    IF BYTESTOGET=0 THEN BYTESTOGET=512
    VADDR = $FA00 + CWORD(BMX_FIRSTPAL)*2

    ASM
     ldx #4
     jsr {CHKIN}
     lda #0
     sta {VERA_CTRL}
     lda {VADDR}
     sta {VERA_ADDR_LOW}
     lda {VADDR}+1
     sta {VERA_ADDR_MID}
     lda #%00010001
     sta {VERA_ADDR_HI}
    END ASM

DO
   BYTES_TO_READ=BYTESTOGET-TMPBYTES
   IF BYTES_TO_READ>255 THEN BYTES_TO_READ=255
   ASM
    lda {BYTES_TO_READ}
    ldx #$23
    ldy #$9F
    sec
    jsr {MACPTR}
    clc
    txa
    adc {TMPBYTES}
    sta {TMPBYTES}
    tya
    adc {TMPBYTES}+1
    sta {TMPBYTES}+1
   END ASM
LOOP WHILE (TMPBYTES < BYTESTOGET)

REM NOW WE LOAD THE IMAGE TO VERA GRAPHICS BUFFER
   IF BMX_WIDTH < 320 THEN
      CALL READSMALLIMAGE()
      CLOSE 4
      GOTO THEEND
    END IF
    BYTES_TO_READL = CLONG(BMX_WIDTH) * CLONG(BMX_HEIGHT)
    ASM
      lda %00010000
      sta {VERA_ADDR_HI}
    END ASM
    IF BMX_HEIGHT=240 THEN Y=0 ELSE Y=(((YLIMIT+1)-BMX_HEIGHT)/2)
    ASM
     lda #0
     sta {R0L}
     sta {R0H}
     sta {R1H}
     lda {Y}
     sta {R1L}
     jsr {FB_cursor_position}
    END ASM
    A=0
    XR = 0
    YR = 0
    TMPBYTESL=0

  DO
    TMPL = BYTES_TO_READL - TMPBYTESL
    IF TMPL > 511 THEN A=0
    IF TMPL < 512 THEN A=255
    IF TMPL < 255 THEN A=TMPL
    ASM
     lda {A}
     ldx #$23
     ldy #$9F
     sec
     jsr {MACPTR}
     stx {XR}
     sty {YR}
    END ASM
    TMPBYTESL = TMPBYTESL + SHL(YR,8) + XR
 LOOP UNTIL (TMPBYTESL = BYTES_TO_READL)

THEEND:
   CLOSE 4
   ASM
    jsr {CLRCHN}
    rts
   END ASM

DECPAL:
ASM
mainstart:
        LDA VERA_addr_high
        PHA
        LDA VERA_addr_low
        PHA
        LDA VERA_data0   ; READ GB
        LDX VERA_data0   ; READ R
        PHA              ; PUSH A
        AND #$0F         ; A is now BLUE
        TAY              ; Y IS NOW BLUE
        BEQ skipbluedec
        DEY              ; DEC BLUE
skipbluedec:
        PLA              ; POP A  (ORIGINAL GB)
        LSR
        LSR
        LSR
        LSR              ; A is now Green
        BEQ skipgreendec
        DEA              ; DECREMENT GREEN
skipgreendec:
        ASL
        ASL
        ASL
        ASL               ; A IS NO G0
        STY R15L          ;
        ORA R15L          ; A IS NOW GB DECREMENTED.
        CPX #0
        BEQ skipreddec
        DEX               ; DEC RED
skipreddec:
        TAY
        PLA
        STA VERA_addr_low
        PLA
        STA VERA_addr_high
stowit:
        STY VERA_data0
        STX VERA_data0
        DEC R0L
        LDX R0L
        CPX #$FF
        BNE mainstart
        RTS
END ASM

   CLOSE 4
   FEEDBACK = "contbmx"
   CALL Flush_Kbd_Buffer()
   PRINT "{BLACK}{1}{BLACK}"
   ASM
    lda #13
    jsr {Put_Kbd_Buf}
    lda #"R"
    jsr {Put_Kbd_Buf}
    lda #"U"
    jsr {Put_Kbd_Buf}
    lda #"N"
    jsr {Put_Kbd_Buf}
    lda #13
    jsr {Put_Kbd_Buf}
  END ASM

  END






