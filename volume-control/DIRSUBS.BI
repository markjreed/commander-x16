PUSHDIR: S$=CWD$ OPEN 15,DEVICE,15,"CD:"+New.Dir$ INPUT#15,DE%,FC$,A,Z:CLOSE 15 DE%=(DE%<20) IF NOT DE% THEN DIR.ERROR HAS.SLASH=0   FOR Z=1 TO LEN(New.Dir$):IF MID$(New.Dir$,Z,1)="/" THEN HAS.SLASH=TRUE:Z=LEN(New.Dir$)   NEXT Z IF NOT HAS.SLASH THEN S$="../" Sub.Ptr=LEN(S$)+1 SAddr=Dir.Ptr - Sub.Ptr IF SAddr<$A000 THEN DirStack.Overflow BANK Dir.Stack GOSUB POKE.STRING Dir.Ptr=Dir.Ptr - Sub.Ptr Dir.Level=Dir.Level + 1 GOSUB GetCWD RETURNPOPDIR: If Dir.Level=0 THEN DirStack.Overflow SAddr=Dir.Ptr BANK Dir.Stack GOSUB PEEK.STRING Add.Ptr=  LEN(S$)+1 Dir.Ptr = Dir.Ptr + Add.Ptr IF Dir.Ptr>$C000 THEN PRINT S$;" ";HEX$(Dir.Ptr):GOTO DirStack.Overflow OPEN 15,DEVICE,15,"CD:"+S$ INPUT#15,DE%,FC$,A,Z:CLOSE 15 CLOSE 15 DE%=(DE%<21) IF NOT DE% THEN POPDIR.ERROR GOSUB GetCWD$ Dir.Level=Dir.Level - 1 RETURNDirStack.Overflow: ERR$= "{CR}{LIGHT RED}DIR STACK OVERFLOW/UNDERFLOW. DIR.PTR="+HEX$(Dir.Ptr)+"    CWD: "+CWD$ GOTO ERREDOUTDIR.ERROR: ERR$="{CR}{LIGHT RED} PUSHING DIRECTORY ERROR {YEL}"+New.Dir$+"{LIGHT GREEN} !!{CR}" GOTO ERREDOUTPOPDIR.ERROR: ERR$="{CR}{LIGHT RED}POPPING DIRECTORY ERROR {LIGHT GREEN}!!{CR}"ERREDOUT: PRINT ERR$ ENDPEEK.STRING: L=PEEK(SAddr):IF L=0 THEN S$="":RETURN S$=RPT$(32,L) ADDR=SAddr+1 POKE 2, FN LO.Byte(ADDR) POKE 3, FN HI.Byte(ADDR) P=POINTER(S$) POKE 4, PEEK(P+1) POKE 5, PEEK(P+2) POKE 6, L POKE 7, 0 SYS $FEE7 RETURNPOKE.STRING: L=LEN(S$) Addr=SAddr+1 POKE SAddr, L POKE R1L, FN LO.Byte(Addr) POKE R1H, FN HI.Byte(Addr) P=POINTER(S$) POKE R0L, PEEK(P+1) POKE R0H, PEEK(P+2) POKE R2L, L POKE R2H, 0 SYS MEM.COPY RETURNDIREXISTS:  GOSUB GetCWD  OPEN 15,DEVICE,15,"CD:"+D$  INPUT#15,DE%,FC$,Y,Z:CLOSE 15:RETURN  DE%=(DE%<20)  IF DE% THEN DC$="CD:"+CWD$:DOS DC$  RETURNGetCWD:  CWD$=""  OPEN 8, DEVICE, 0, "$=C"## SKIP LOAD ADDR  GET# 8, X$: GET# 8, X$  ## SKIP VOLUME LABEL  GET# 8, X$: GET# 8, X$: GET# 8, X$: GET# 8, X$: LINPUT# 8, X$, 0CWD.Loop:## SKIP LINK AND SIZE  GET# 8, X$: GET# 8, X$: GET# 8, X$: GET# 8, X$## SKIP TO FIRST QUOTE  LINPUT# 8, X$, 34## READ TO NEXT QUOTE  LINPUT# 8, D$, 34## SKIP TO END OF ENTRY  LINPUT# 8, X$,  0  IF (LEN(D$)<>0) AND ASC(D$) THEN GOSUB CWD.Builder  IF (ST AND 64) = 0 THEN CWD.Loop  CLOSE 8  RETURNCWD.Builder:  IF LEN(CWD$) AND (D$ <> "/") THEN CWD$ = "/" + CWD$  FOR I=LEN(D$) TO 1 STEP -1    C$ = MID$(D$, I, 1): C=ASC(C$)    IF (C >  96) AND (C < 123) THEN C = C -  32    IF (C > 192) AND (C < 219) THEN C = C - 128    CWD$ = CHR$(C) + CWD$  NEXT  RETURN