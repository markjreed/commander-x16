#CONTROLCODES 1
#SYMFILE "@:README.SYM"
#INCLUDE "VGACOLORS.DEF"

  ORIGBANK1=PEEK(0)
  ORIGBANK2=PEEK(1)
  DEVICE=8
  UP$=CHR$(145)
  ARROWS$=CHR$($80)+CHR$($18)+CHR$($80)+CHR$($19)
  GOSUB POKENOFLICKER:GOSUB SETREGVARS
  MYMODE=1:GOSUB NOFLICKERSCREEN
  FGROUND = BLACK
  BGROUND = VGA.WHITE
  SAVEBANK=60
  DIM DCHARS%(10)
  GOSUB SET.VGATextColors
  GOSUB SET.ThinCP437
  GOSUB LoadDCharsCP437
  SCREEN 1
  COLOR 15,VGA.BLACK2:CLS
  LOCATE 30,68
  COLOR VGA.WHITE:PRINT "[";
  COLOR VGA.LITEGREEN:PRINT "ESC";
  COLOR VGA.WHITE:PRINT "]-";
  COLOR VGA.LITERED:PRINT "Exit";
  LOCATE 30,22
  COLOR VGA.WHITE:PRINT "[";
  COLOR VGA.LITEGREEN:PRINT "PGDN/PGUP";
  COLOR VGA.WHITE:PRINT "]-";
  COLOR VGA.LITERED:PRINT "Text Page";
  LOCATE 30,47
  COLOR VGA.WHITE:PRINT "[";
  COLOR VGA.LITEGREEN:PRINT "F12";
  COLOR VGA.WHITE:PRINT "]-";
  COLOR VGA.LITERED:PRINT "Dark";
  COLOR VGA.YELLOW:PRINT "/";
  COLOR VGA.LITERED:PRINT "Light";



  LOCATE 30,2: COLOR VGA.WHITE:PRINT "[";
  COLOR VGA.LITEGREEN:PRINT ARROWS$;
  COLOR VGA.WHITE:PRINT "]-";
  COLOR VGA.LITERED:PRINT "Line Advance";
  GOSUB SHOWTEXT
  LOCATE 1,1
  REM POKE A.REG, 13
  REM POKE X.REG, 80
  REM POKE Y.REG, 29
  REM SYS $FEAB
  REM VPOKE 1,$FA1E, $DD
  REM VPOKE 1,$FA1F, $D
  COLOR VGA.WHITE,BLACK:CLS
  GOSUB CHECK.FOR.FILE
  IF THEFILE$<>"" THEN F$=THEFILE$:GOTO CHECK.IF.IT.IS.THERE
RETRYIT:
  LOCATE 1,1
  PRINT "FILE NAME: ";
  LINPUT F$
  IF F$="DONE" THEN READDONE
CHECK.IF.IT.IS.THERE:
  GOSUB FILEEXISTS
  IF NOT FE% THEN GOTO RETRYIT
  LOCATE 3,2:COLOR VGA.LITEGREEN:PRINT "F1 ";
  COLOR VGA.WHITE:PRINT " - For HELP";
  THEFILE$=F$
  CHANNEL=4:P0=0:P1=0:P2=0:P3=0
  OPEN 4,8,4,THEFILE$+",S,R":GOSUB SET.LINE.END
  GOSUB POKEFASTFWD
  FILE.LINE = 1
  SLEEP 90
  GOSUB SHOWPAGE

WAITKEY:
  GET X$:IF X$="" THEN WAITKEY

  K=ASC(X$):IF K=27 THEN READDONE
  IF K=133 THEN GOSUB HELPBOX:GOTO WAITKEY
  IF K=23 THEN GOSUB SWAP.SCREEN.COLORS:GOTO WAITKEY
  IF K=17 THEN GOSUB NEXT.LINE:GOTO WAITKEY
  IF K=145 THEN GOSUB TOP.LINE
  IF K=2 AND EOF THEN FMDRUM 7,87:GOTO WAITKEY
  IF K=2 THEN FILE.LINE=FILE.LINE+29:GOSUB SEEK.LINE:GOSUB SHOWPAGE
  IF K=130 AND FILE.LINE=1 THEN FMDRUM 7,87:GOTO WAITKEY
  IF K=130 THEN IF FILE.LINE>1 THEN FILE.LINE=FILE.LINE-29:IF FILE.LINE<1 THEN FILE.LINE=1
  IF K=130 THEN GOSUB SEEK.LINE:GOSUB SHOWPAGE
  GOTO WAITKEY

READDONE:
  GOTO CLEANUP.AND.END

SHOWPAGE:
 IF FILE.LINE=1 THEN CLOSE 4:OPEN 4,8,4,THEFILE$+",S,R"
 FCOUNT=0
 COLOR FGROUND, BGROUND
 CLS
DOLOAD:
 FOR J=1 TO 30
   LINPUT# 4, X$,LINE.ENDING
   IF IS.WINDOWS.FILE THEN GET# 4,T$
   L=LEN(X$)
   EOF = (ST<>0)
   FCOUNT = FCOUNT+1
   PRINT LEFT$(X$,80);
   IF LEN(X$)<80 AND J<30 THEN PRINT
   IF EOF THEN J=30
 NEXT J
 IF EOF THEN CLOSE 4
 AT.SCREEN.BOTTOM = -1
RETURN


NEXT.LINE:
   IF EOF THEN FMDRUM 7,87:RETURN
   IF AT.SCREEN.BOTTOM THEN PRINT:GOTO SKIP.ADJUST
   LOCATE 30,1:PRINT CHR$(17);
   LOCATE 30,1
   AT.SCREEN.BOTTOM=-1
   SLINE=FILE.LINE
   FILE.LINE=SLINE+FCOUNT:GOSUB SEEK.LINE
   FILE.LINE=SLINE
SKIP.ADJUST:
   LINPUT# 4, X$,LINE.ENDING
   IF IS.WINDOWS.FILE THEN GET# 4,T$
   EOF = (ST<>0)
   FILE.LINE=FILE.LINE+1
   PRINT LEFT$(X$,80);
   IF EOF THEN CLOSE 4
RETURN

TOP.LINE:
   IF FILE.LINE=1 THEN FMDRUM 7,87:RETURN
   IF EOF THEN CLOSE 4:OPEN 4,8,4,THEFILE$+",S,R"
   AT.SCREEN.BOTTOM = 0
   LOCATE 1,1:PRINT UP$
   SLINE=FILE.LINE
   FILE.LINE=FILE.LINE-1:GOSUB SEEK.LINE
   IF EOF THEN FMDRUM 7,87:FILE.LINE=SLINE:RETURN
   LINPUT# 4, X$,LINE.ENDING
   IF IS.WINDOWS.FILE THEN GET# 4, T$
   EOF = (ST<>0)
   L=LEN(X$)
   IF L>80 THEN LOCATE 1,1:PRINT UP$
   IF L>160 THEN LOCATE 1,1:PRINT UP$
   IF L>240 THEN LOCATE 1,1:PRINT UP$
   LOCATE 1,1
   PRINT LEFT$(X$,80);
RETURN

SEEK.LINE:
 IF EOF THEN CLOSE 4:OPEN 4,8,4,THEFILE$+",S,R":EOF=0
 GOSUB POSITION
 IF FILE.LINE=1 THEN RETURN
 TL=(FILE.LINE)-1
 POKE A.REG,4:POKE Y.REG, INT(TL/256):
 POKE X.REG, TL-PEEK(Y.REG)*256:
 CALL=STRPTR(FASTFWD$):SYS CALL
 IF IS.WINDOWS.FILE THEN GET# 4, T$
 EOF = (ST<>0)
RETURN

HELPBOX:
  Y=9:X=22:W=40:H=12:COLOR BGROUND, FGROUND:GOSUB TEXTBOX
  LOCATE 11,32
  COLOR BGROUND:PRINT "[";
  COLOR VGA.GREEN:PRINT ARROWS$;
  COLOR BGROUND:PRINT "] - ";
  PRINT "Line by Line";
  LOCATE 13,25
  COLOR BGROUND:PRINT "[";
  COLOR VGA.GREEN:PRINT "PGUP/PGDN";
  COLOR BGROUND:PRINT "] - ";
  PRINT "Page by Page";
  LOCATE 15,31
  COLOR BGROUND:PRINT "[";
  COLOR VGA.GREEN:PRINT "F12";
  COLOR BGROUND:PRINT "] - ";
  PRINT "Light / Dark";
  LOCATE 17,31
  COLOR BGROUND:PRINT "[";
  COLOR VGA.GREEN:PRINT "ESC";
  COLOR BGROUND:PRINT "] - ";
  PRINT "Exit text viewer";
GETXDOLLARSIGN:
  GET X$:IF X$="" THEN GETXDOLLARSIGN
  GOTO SHOWPAGE

TEXTBOX:
  LOCATE Y,X:PRINT CHR$(DChars%(1));RPT$(DChars%(2),W-2);CHR$(DChars%(3));
  IF H=2 THEN SKIPMID
  BStart=Y+1:BEnd=Y+(H-2)
  FOR Y2 = BStart TO BEnd:LOCATE Y2,X:PRINT CHR$(DChars%(4));RPT$(32,W-2);CHR$(DChars%(5));:NEXT
SKIPMID:
  LOCATE Y+H-1,X:PRINT CHR$(DChars%(6));RPT$(DChars%(7),W-2);CHR$(DChars%(8));:RETURN

ERRORHALT.LOCAL2:
 PRINT:PRINT DM$:PRINT:PRINT
 F$=My.Loader$:GOSUB FILEEXISTS
 IF NOT FE% THEN END
 PRINT "{YEL}PRESS{WHT} ANY KEY"
FLUSH:
  GET X$:IF X$<>"" THEN FLUSH
KEYPRESS:
  GET X$:IF X$="" THEN KEYPRESS
LOADIT:
  LOAD My.Loader$


NOFLICKERSCREEN:
 POKE A.REG, MYMODE
 ADDR=STRPTR(NOFLCKER$)
 SYS ADDR:GOTO SET.VGATextColors

POKENOFLICKER:
  RESTORE NOFLICKER
  NOFLCKER$=""
  FOR A=$400 TO $433
      READ C
      NOFLCKER$=NOFLCKER$+CHR$(C)
  NEXT A
  RETURN

POKEFASTFWD:
   RESTORE FASTFWD650
   FASTFWD$=""
   FOR A=$440 TO $470:READ C:
   IF LINE.ENDING=10 AND C=$0D THEN C=10
   FASTFWD$=FASTFWD$+CHR$(C):NEXT A:RETURN

## 52 BYTES
NOFLICKER:
 DATA $5A,$DA,$48,$A9,$FA,$8D,$21,$9F,$A9,$11,$8D,$22,$9F,$A9,$00,$8D
 DATA $20,$9F,$A2,$04,$A0,$80,$8D,$23,$9F,$88,$D0,$FA,$CA,$D0,$F5,$20,$DE,$FF
 DATA $85,$29,$CB,$20,$DE,$FF,$C9,$FF,$F0,$F8,$68,$18,$20,$5F,$FF,$FA,$7A,$60

## 49 BYTES
FASTFWD650:
  DATA $E0,$00,$D0,$05,$C0,$00,$F0,$24,$88,$C8,$84,$22,$DA,$AA,$20,$C6,$FF,$7A
  DATA $20,$CF,$FF,$C9,$0D,$D0,$07,$88,$D0,$04,$C6,$22,$F0,$0C,$20,$B7,$FF,$29
  DATA $40,$F0,$EB,$20,$CC,$FF,$38,$60,$20,$CC,$FF,$18,$60

SWAP.SCREEN.COLORS:
 CBYTE=VPEEK(1,$B001)
 LOW.NIBBLE = CBYTE AND $0F:BGROUND=LOW.NIBBLE
 HIGH.NIBBLE = (CBYTE AND $F0) / 16:FGROUND=HIGH.NIBBLE
 COLOR FGROUND, BGROUND
 CBYTE = (LOW.NIBBLE*16) + HIGH.NIBBLE
 POKE $9F20, $01
 POKE $9F21, $B0
 POKE $9F22,%00100001
 POKE R0L, $23
 POKE R0H, $9F
 POKE R1L, $00
 POKE R1H, $0F
 POKE A.REG, CBYTE
 SLEEP:SYS MEM.FILL
RETURN

REM SET.SCREEN.LINES:
  REM POKE A.REG, 13
  REM POKE X.REG, 80
  REM POKE Y.REG, SCREEN.LINES
  REM SYS $FEAB
  REM RETURN

SETREGVARS:
  A.REG = $030C
  X.REG = $030D
  Y.REG = $030E
  C.REG = $030F
  SET.MEM = $FF99
  R0L=$02:R0H=$03:R0=R0L
  R1L=$04:R1H=$05:R1=R1L
  R2L=$06:R2H=$07:R2=R2L
  R3L=$08:R3H=$09:R3=R3L
  R4L=$A:R4H=$B:R4=R4L
  R5L=$C:R5H=$D:R5=R5L
  R6L=$E:R6H=$F:R6=R6L
  R7L=$10:R7H=$11:R7=R7L
  R8L=$12:R8H=$13:R8=R8L
  R9L=$14:R9H=$15:R9=R9L
  R10L=$16:R10H=$17:R10=R10L
  R11L=$18:R11H=$19:R11=R11L
  R12L=$1A:R12H=$1B:R12=R12L
  R13L=$1C:R13H=$1D:R13=R13L
  R14L=$1E:R14H=$1F:R14=R14L
  R15L=$20:R15H=$21:R15=R15L
  CHKOUT=$FFC9:CHKIN=$FFC6:CLRCHN=$FFCC
  MCIOUT=$FEB1:MACPTR=$FF44:
  VERA.DATA0=$9F23:VERA.DATA1=$9F24:VERA.CTRL=$9F25
  VERA.DCVIDEO=$9F29
  LAYER0.ON=16
  LAYER0.OFF=239
  LAYER1.ON=32
  LAYER1.OFF=223
  FB.CURSOR.POSITION=$FEFF
  FB.CURSOR.NEXTLINE=$FF02
  SCREEN.SIZE=$12C00
  SET.CHARSET = $FF62
  MEM.COPY = $FEE7
  MEM.FILL = $FEE4
DO.DEFINES:
  DEF FN PEEKW(A)=PEEK(A)+(PEEK(A+1)*256)
## CONVERT TO SIGNED RANGE
  DEF FN SW(W)=W + 65536 * (W > 32767)
## CONVERT TO UNSIGNED RANGE
  DEF FN UW(W)=W-65536*(W<0)

  DEF FN Lo.Byte(X)=(FN SW(X)) AND $FF
  DEF FN Hi.Byte(X)=INT(FN UW(X)/256)
  DEF FN SIGNED.BYTE(N) = N+256*(N>127)

  DEF FN ROUND(X) = INT(X+.5)
  RETURN

SET.ThinCP437:
   OB2=PEEK(0)
   PRINT "{ISO ON}
   REM SET ISO THIN FONT
   POKE A.REG,6:SYS SET.CHARSET
   POKE $9F20, $08:POKE $9F21,$F1:POKE $9F22,%00010001
   POKE R0L,$23:POKE R0H,$9F:POKE R1L,$00:POKE R1H,$BC
   POKE R2L, 0:POKE R2H, $03:BANK 10
   SYS MEM.COPY
   POKE A.REG,7:SYS SET.CHARSET
   POKE $9F20,$08:POKE $9F21,$F1:POKE $9F22, %00010001
   POKE R1L,$23:POKE R1H,$9F:POKE R0L,$00:POKE R0H,$BC
   POKE R2L, 0:POKE R2H, $03:BANK 10
   SYS MEM.COPY
   ## HERE We grab a single PETSCII character back to the Font.. The DIAMOND
     OB=PEEK(1):BANK PEEK(0),6:CA=$C2D0:VA=$F748
       FOR I=0 TO 7
           X=PEEK(CA+I):VPOKE 1,VA+I,X
       NEXT I
   BANK OB2,OB
   GOTO FIXCURSOR

SETDEFAULTPALETTE:
  F$="DPAL.BIN":GOSUB FILEEXISTS
  IF FE% THEN BVLOAD F$,DEVICE,1,$FA00:RETURN
  PRINT "MISSING DPAL.BIN !!":GOSUB SHOWTEXT:END

SET.VGATextColors:
   POKE $9F20, 0:POKE $9F21, $FA:POKE $9F22, %00010001
   RESTORE VGATEXTCOLORS
   FOR I=0 TO 31:READ C:POKE $9F23, C:NEXT:COLOR 15:RETURN

#INCLUDE "VGATEXT.BI"

HIDEALL:
  GOSUB HIDEGRAPHICS:GOTO HIDETEXT
SHOWALL:
  GOSUB SHOWGRAPHICS:GOTO SHOWTEXT

HIDEGRAPHICS:
  POKE VERA.DCVIDEO, PEEK(VERA.DCVIDEO) AND LAYER0.OFF:RETURN

SHOWGRAPHICS:
  POKE VERA.DCVIDEO, PEEK(VERA.DCVIDEO) OR LAYER0.ON:RETURN

HIDETEXT:
  POKE VERA.DCVIDEO, PEEK(VERA.DCVIDEO) AND LAYER1.OFF:RETURN

SHOWTEXT:
  POKE VERA.DCVIDEO, PEEK(VERA.DCVIDEO) OR LAYER1.ON:RETURN

FILEEXISTS:
  OPEN 2,DEVICE,2,F$+",S,R":CLOSE 2
  GOSUB GETFILECODE
  FE%=(FCode<=20):RETURN

SET.LINE.END:
   FOR I=0 TO -1 STEP 0
       GET# 4, X$
       C=ASC(X$)
       I=(C=13 OR C=10)
   NEXT I
   IF C=10 THEN LINE.ENDING = 10:RETURN
   LINE.ENDING=13
   GET# 4, X$
   IF X$=CHR$(10) THEN IS.WINDOWS.FILE=-1
   RETURN

POSITION:
  COMMAND$="P"+CHR$(CHANNEL)+CHR$(P0)+CHR$(P1)+CHR$(P2)+CHR$(P3)

DOS.CMD:
 OPEN 15,DEVICE,15, COMMAND$
 GOTO GETFCODE

GETFILECODE:
  OPEN 15,8,15
GETFCODE:
  INPUT#15,FCode,FC$,A,B:CLOSE 15:RETURN

FIXCURSOR:
  FBASE=$9F*8+$F000
  FOR X=0 TO 6:VPOKE 1,FBASE+X,0:NEXT X
  VPOKE 1,FBASE+7,$FF
  RETURN

CHECK.FOR.FILE:
  OB = PEEK(0)
  BANK 0
  WORKBANK = PEEK($BFFE)
  BANK WORKBANK
  SAddr=$BD00:GOSUB PEEK.STRING
  THEFILE$=""
  File.TCheck = (S$="LOADFILE:")
  IF File.TCheck THEN SAddr=$BD10:GOSUB PEEK.STRING:THEFILE$=S$:S$="DONEREAD:":SAddr=$BD00:GOSUB POKE.STRING
  SAddr = $BE00:GOSUB PEEK.STRING
  LOAD.RETURN = (S$="MYLOADER:")
  IF LOAD.RETURN THEN SAddr=$BE10:GOSUB PEEK.STRING:My.Loader$=S$
  BANK OB
RETURN

CLEANUP.AND.END:
 REM POKE A.REG, 13
 REM POKE X.REG, 80
 REM POKE Y.REG, 30
 REM SYS $FEAB
 SYS $FFE7
 OPEN 15,8,15
 FOR I=0 TO -1 STEP 0
   INPUT# 15, E,EM$,T,S
   I= (EM$="OK")
 NEXT
 CLOSE 15
 COLOR 0,0:CLS
 MYMODE=0:GOSUB NOFLICKERSCREEN
 COLOR 0,0:CLS
 F$=My.Loader$:GOSUB FILEEXISTS
 BANK ORIGBANK1, ORIGBANK2
 IF FE% AND LOAD.RETURN THEN LOAD My.Loader$
 COLOR 1,6:CLS:BANNER:END

PEEK.STRING:
 L=PEEK(SAddr):IF L=0 THEN S$="":RETURN
 S$=RPT$(32,L)
 ADDR=SAddr+1
 POKE 2, FN LO.Byte(ADDR)
 POKE 3, FN HI.Byte(ADDR)
 P=POINTER(S$)
 POKE 4, PEEK(P+1)
 POKE 5, PEEK(P+2)
 POKE 6, L
 POKE 7, 0
 SYS $FEE7
 RETURN

POKE.STRING:
 L=LEN(S$)
 Addr=SAddr+1
 POKE SAddr, L
 POKE R1L, FN LO.Byte(Addr)
 POKE R1H, FN HI.Byte(Addr)
 P=POINTER(S$)
 POKE R0L, PEEK(P+1)
 POKE R0H, PEEK(P+2)
 POKE R2L, L
 POKE R2H, 0
 SYS MEM.COPY
 RETURN

LoadDCharsCP437:
 RESTORE CP437DRAW
 GOTO Load.Them.Chars

LoadDChars:
  RESTORE PETSCIIDRAW
Load.Them.Chars:
  FOR I=1 TO 8
   READ DChars%(I)
  Next
  RETURN

PETSCIIDRAW:
 DATA $CF,$B7,$D0,$B4,$AA,$CC,$EF,$BA

CP437DRAW:
 DATA $C9,$CD,$BB,$BA,$BA,$C8,$CD,$BC
